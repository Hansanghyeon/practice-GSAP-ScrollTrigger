# ScrollTrigger

ScrollTrigger는 최소한의 코드로 놀라운 스크롤 기반 애니메이션을 만듭니다. 애니메이션과 관련이 없는 경우에도 스크롤 관련 항목을 트리거합니다.

**Feature highlights**

- **특정 요소에 애니메이션을 연결하여** 해당 요소가 뷰포트에 있을 때만 재생되도록 합니다. 이렇게하면 성능이 향상되고 아름다운 애니메이션이 실제로 표시됩니다!
- ScrollTrigger는 정의 된 영역에 들어가거나 나갈 때 애니메이션에 대한 작업 (재새, 일시 중시, 다시 시작, 되감기, 완료, 재설정)을 수행하거나 스크러버 처럼 작동하도록 스크롤바에 직접 연결할 수 있습니다. (`scrub: true`).
- **애니메이션과 스크롤바 사이의 링크를 부드럽게하여** 따라 잡는 `scrub: 1`데 1초가 걸리는 것처럼 일정 시간이 걸리도록 합니다.
- 속도를 기준으로 애니메이션의 특정 지점에 스냅합니다. 사실, `getVelocity()` 언제든지 스크롤 할 수 있습니다. 타임 라인에서 가장 가까운 레이블 또는 어레이의 진행률 값에 스냅하거나 스냅을 위한 사용자 지정 함수 기반 논리를 실행합니다.
- **스크롤 트리거를 GSAP 애니메이션**(타임라인 포함)에 직접 포함하거나 독립형 인스턴스를 만들고 풍부한 콜백 시스템을 활용하여 원하는 작업을 수행 할 수 있습니다.
- 고급 고성 기능은 특정 스크롤 ㅟ치 사이에 요소를 고정 할 수 있습니다. 그에 따라 다른 요소를 아래로 밀어 내기 위해 패딩이 자동으로 추가되므로 요소가 고정 해제되면 따라 잡습니다(이를 사용하여 비활성화 `pinSpacing: false`). 동일한 요소를 다른 지점에 여러 번 고정 할 수 도 있습니다.
- 스크롤 위치를 정의하는 놀라운 유연성 - "이 요소의 중심이 뷰 포트의 중앙에 닿으면 시작하고 다른 요소의 하단이 뷰포트의 하단에 닿으면 종료"와 같이 키워드 (top, center, bottom, left)를 사용합니다. 오른쪽, 백분율, 픽셀 또는 `+=300px`. 구문에 익숙해지면 매우 직관적입니다.
- 수용 수직 또는 수평 스크롤을
- onEnter, onLeave, onEnteBack, onLeaveBack, onToggle, onUpdate, onScrubComplete 및 onRefresh를 포함한 풍부한 콜백 시스템.
- 창 크기가 조정되면 자동으로 위치를 다시 계산합니다.
- 개발 중에 시각적 마커를 활성화 하여 시작/종료/트리거 지점이 정확히 어디에 있는지 확인합니다. 사용자 지정 옵션은 `markers: {startColor: "green", endColor: "red", fontSize: "12px"}`
- **CSS 클래스를 전환합니다** 에를 들어, `toggleClass: "active"` ScrollTrigger가 활성 상태인 동안 트리거 요소에 `active` 클래스를 추가합니다. 다른 요소에도 영향을 미칠 수 있습니다.
- response - 사용 `matchMedia()` 표준 미디어 쿼리를 사용하여 다양한 화면 크리에 대해 서로 다른 설정을 생성하는 방법을.
- custom container - 뷰포트를 사용할 필요가 없습니다. 대신 `<div`와 같은 사용자 지정 스크롤러를 정의하십시오.
- 최대 성능을 위해 고도로 최적화 됨. - 스크롤 이벤트가 디 바운스되고 업데이트가 GSAP 및 화면 새로 고침과 동기화되며 크기 재 계산이 조절됩니다. 
- 스크롤 재킹이 없으므로 CSS 스크롤 스냅과 같은 기본 기술과 결합할 수 있습니다. 스크롤 재킹을 원하는 경우 `scrollerProxy()` 메서드를 사용하여 타사 부드러운 스크롤 라이브러리와 통합 할 수 있습니다.
